<?xml version="1.0" encoding="UTF-8"?>
<?xml-model href="http://docbook.org/xml/5.0/rng/docbook.rng" schematypens="http://relaxng.org/ns/structure/1.0"?>
<?xml-model href="http://docbook.org/xml/5.0/rng/docbook.rng" type="application/xml" schematypens="http://purl.oclc.org/dsdl/schematron"?>
<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink"
    version="5.0" xml:id="ch_sampleModule">
    <title>Customize the SampleModules</title>
    <para> With Pepper we tried to avoid as much complexity as possible without reducing the
        funtionality. We want to enable you to concentrate on the main issues, which are the mapping
        of objects. This trade-off has been realized by first using some default assumptions, which
        reduces complexity in a lot of cases and second by class derivation and call-back methods,
        to still provide the full range of adoption possibilities if necessary. <itemizedlist>
            <listitem>
                <para>Now some words to the general architecture of a Pepper module and the
                    interaction with the Pepper framework.</para>
            </listitem>
            <listitem>
                <para>small class diagram PepperModule, PepperExporter, PepperImporter and
                    PepperManipulator and PepperMapper</para>
            </listitem>
            <listitem>
                <para>What is PepperExporter, PepperImporter and PepperManipulator</para>
            </listitem>
            <listitem>
                <para>PepperModule vs. PepperMapper - reason is threading</para>
                <para>Since a mapping process can be relatively time consuming, we could decrease
                    the needed time to map an entire corpus, if we are able to process mapping tasks
                    simultaneously. In Pepper each module can be ran in multi-threading mode by
                    default. But keep in mind, that multi-threading can not be added to a module as
                    a new feature. It needs an implementor to take care of this during all the
                    implementation work. If you are not familar with multi-threading in Java, we
                    want to give the hint to avoid class variables and methods. The same goes for
                    static variables and methods<footnote>
                        <para>If such a variable never is changed or such a method only returns
                            constants, you can even use them. Marking methods with the keyword
                            synchronized and variables with the keyword volatile can also help to
                            avoid mult-threading problems.</para>
                    </footnote>. If it is still necessary, to use such constructs, we recommend, to
                    go deeper in the sometimes annoying but powerfull world of multi-threading. If
                    you do not want to blow up things and don't want to benefit from the better
                    performance, you can also switch off multi-threading by a flag (just call the
                    method <methodname>setIsMultithreaded(false)</methodname> in your modules
                    constructor). </para>
            </listitem>
            <listitem>
                <para>show sequence diagram</para>
            </listitem>
            <listitem>
                <para>In Salt and Pepper we differentiate between the corpus-structure and the
                    document-structure. The document-structure contains the primary data (data
                    sources) and the linguistic annotations. A bunch of such information is grouped
                    to a document (<classname>SDocument</classname> in Salt). The corpus-structure
                    now is a grouping mechanism to group several documents to a corpus or sub-corpus
                        (<classname>SCorpus</classname> in Salt).</para>
            </listitem>
        </itemizedlist>
    </para>


    <para>WHERE TO PUT THIS??? The Pepper project and therefore even the single Pepper module
        projects are using a bunch of frameworks under the hood. With some you will get in contact
        while you are developing your module, others will stay under the hood. But here we want to
        mention them and give an impression of their impact. <itemizedlist>
            <listitem>
                <para>OSGi<footnote>
                        <para>see XXX</para>
                    </footnote> - OSGi is a plug-in framework. Pepper is making heavy use of OSGi,
                    to plug-in Pepper modules into the main Pepper program.</para>
            </listitem>
            <listitem>
                <para>Maven<footnote>
                        <para>see XXX</para>
                    </footnote> - Maven is a lifecycle and dependency management system. Maven
                    organizes the build process of Pepper modules. </para>
            </listitem>
            <listitem>
                <para>JUnit 4<footnote>
                        <para>see XXX</para>
                    </footnote> - Junit is a testing framework, for testing single classes. In
                    section XXX we dig more sepecific into this topic, but generally spoken, Pepper
                    provides a small test framework for helping developing a module basing on JUnit.
                </para>
            </listitem>
            <listitem>
                <para>SLF4J<footnote>
                        <para>see XXX</para>
                    </footnote> - SLF4J is a logging framework, which provides an abstraction for
                    several other logging frameworks like log4j and java.util logging. You will find
                    more information about logging in section XXX.</para>
            </listitem>
        </itemizedlist> Unfortunatly when using powerfull frameworks, they can have some unnice
        impacts, so for instance Maven and OSGi as well contain an own dependency resolving system,
        which could cause some problems. Therefore in Pepper we tried to hide the OSGi layer as much
        as possible and make the configuration only via maven. If you know more about OSGi, please
        note, not to change the META-INF or OSGI_INF entries, since they are automatically created
        by maven. And each maven build will override them. </para>




    <para>We now want to give a brief overview of what to do to adopt the classes of SampleModules
        project. Inside the single items, you will find links to further explanaitions. <orderedlist>
            <listitem>
                <para>[MANDATORY]</para>
                <para>Change the name of the module, for instance to MyImporter, MyExporter etc. We
                    recommend to use the format name and the ending Importer, Exporter or
                    Manipulator (like <classname>FORMATImporter</classname>).</para>
            </listitem>
            <listitem>
                <para>[MANDATORY]</para>
                <para>Change the name of the component<footnote>
                        <para>a component here is an OSGi service component (for more details see
                                <link xlink:href="http://wiki.osgi.org/wiki/Declarative_Services"
                                >http://wiki.osgi.org/wiki/Declarative_Services</link>)</para>
                    </footnote>, for instance use the classes name and add 'Component' to it (e.g.
                    MyImporterComponent) like in the following example.
                    <programlisting>@Component(name="MyImporterComponent", 
                            factory="PepperImporterComponentFactory")
public class MyImporter extends PepperImporterImpl implements PepperImporter</programlisting>
                </para>
            </listitem>
            <listitem>
                <para>[MANDATORY]</para>
                <para>Set the coordinates, with which your module shall be registered. The
                    coordinates (modules name, version and supported formats) are a kind of a
                    fingerprint, which should make your module unique. See the following example:
                    <programlisting>public MyImporterImporter()
{
	super();
	this.name= "MyImporterImporter";
	//we recommend to synchronize this value with the maven version 
	//in your pom.xml
	this.setVersion("1.1.0");
	this.addSupportedFormat("myFormat", "1.0", null);
	//see also predefined endings beginning with 'ENDING_' 
	this.getSDocumentEndings().add("myFormat");
}</programlisting>
                </para>
            </listitem>
            <listitem>
                <para>[OPTIONAL]</para>
                <para>After the module is created, the Pepper framework calls the method
                        <methodname>isReadyToRun()</methodname>, at this stage all intializations of
                    module have been completed, so that now the module can make some own
                    initializations. For instance paths like a path for storing temporary data (see
                        <methodname>getTemporaries()</methodname>) is set and a path, where to find
                    additional resources (see <methodname>getResources()</methodname>) if it is
                    given.
                    <programlisting>public boolean isReadyToStart() 
                            throws PepperModuleNotReadyException
{
    //make some initializations if necessary
    return(true);
}</programlisting></para>
            </listitem>
            <listitem>
                <para>[RECOMMENDED]</para>
                <para>Pepper provides a mechanism to automatically detect, if a format can be read
                    by an importer, therefore you have to override the method
                        <methodname>isImportable(URI corpusPath)</methodname>, which returns a value
                    for determining if the resource at passed path is importable by this module. The
                    return values are 1 if corpus is importable, 0 if corpus is not importable, 0
                    &lt; X &lt; 1, if no definitiv answer is possible, null if the method is not
                    overridden. For further details, see: <xref linkend="sec_analyzing"/>.</para>
            </listitem>
            <listitem>
                <para>[OPTIONAL]</para>
                <para>In case that you are creating an importer, check if the default behavior of
                    the corpus-structure import mechanism fits your needs. For further details, see:
                        <xref linkend="sec_importCorpusStructure"/>.</para>
            </listitem>
            <listitem>
                <para>[MANDATORY]</para>
                <para>The main interesting part of a mapping probably is the mapping of the
                    document-structure. It means the mapping of the real linguistic data, so the
                    reason why we are doing all of this. Since such a mapping is not trivial, we
                    recommand to delegate it to another class which is derived of class
                        <classname>PepperMapper</classname>.</para>
                <para>For further details, or even if you do not want to use the default mechanism,
                    see: <xref linkend="sec_mapDocumentStructure"/>.</para>
            </listitem>
            <listitem>
                <para>[RECOMMENDED]</para>
                <para>Monitoring the progress would give a good feedback to the user. Since the
                    conversion may take a while, we want to prevent the user to kill the conversion
                    job, by providing the progress status. Therefore Pepper offers possibilities for
                    a module to notify the framework about its progress. In case of you are using
                    the default behaviour via <classname>PepperMapper</classname>, call the method
                        <methodname>addProgress(Double progress)</methodname> and pass the
                    additional progress for the current <classname>SDocument</classname> or
                        <classname>SCorpus</classname>. In case of you do not use the default
                    behaviour please override the method <methodname>getProgress(SElementId
                        sDocumentId)</methodname> and <methodname>getProgress()</methodname> in your
                    module. For further details, see: <xref linkend="sec_monitoring"/>.</para>
            </listitem>
            <listitem>
                <para>[OPTIONAL]</para>
                <para>If you have to clean up things (e.g. delete temporary files etc.), override
                    the method <methodname>end()</methodname>, see: <xref linkend="sec_cleanUp"
                    />.</para>
            </listitem>
        </orderedlist> The following figure shows a sequence diagram displaying the sequence of
        method calls between the Pepper framework and the classes to be implemented
            <classname>Peppermodule</classname> and <classname>PepperMapper</classname>. Please
        note, that this is just a simplified representation, some methods are not shown, and a
        further class called <classname>PepperMapperController</classname>, which interacts between
        the <classname>PepperModule</classname> and the <classname>PepperMapper</classname> class is
        also not shown. <figure xml:id="fig_pepperWorkflow">
            <title>Pepper workflow overview</title>
            <mediaobject>
                <imageobject>
                    <imagedata width="608" fileref="images/pepper_workflow.png"/>
                </imageobject>
            </mediaobject>
        </figure> In the following sections, you will find more detailed explanaitions to the prior
        given single steps. If the given information is not enough, please take a look into the
        corresponding JavaDoc. </para>

</chapter>
