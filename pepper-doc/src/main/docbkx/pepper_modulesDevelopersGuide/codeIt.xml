<?xml version="1.0" encoding="UTF-8"?>
<?xml-model href="http://docbook.org/xml/5.0/rng/docbook.rng" schematypens="http://relaxng.org/ns/structure/1.0"?>
<?xml-model href="http://docbook.org/xml/5.0/rng/docbook.rng" type="application/xml" schematypens="http://purl.oclc.org/dsdl/schematron"?>
<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink"
    version="5.0" xml:id="ch_codeIt">
    <title>Just code it</title>
    <para>With Pepper we tried to avoid as much complexity as possible without reducing the
        funtionality. We want to enable you to concentrate on the main issues, which are the mapping
        of objects. But still there are some things you need to know about the framework. Therefore
        we here introduce some aspects of the Pepper framework and its interaction with a Pepper
        module. Reducing the complexity is not always possible, but we tried. To manage this
        trade-off, we followed the approach convention over configuration. That means, we made some
        assumptions, which apply to many mapping tasks. This makes implementing very simple if the
        default case matches. But if not, you always have the possibility to adapt the module to
        your needs. The adaptable default behavior mostly is relaized by class derivation and
        call-back methods, which always can be overridden.</para>
    <para>Pepper differentiates three sorts of modules: the importer, the manipulator and the
        exporter. An importer maps a corpus given in format X to a Salt model. A manipulator maps a
        Salt model to another Salt model, in terms of changing it or just retrieving some
        information. An exporter maps a Salt model to a corpus in format Y. All three modules
            <classname>PepperImporter</classname>, <classname>PepperManipulator</classname> and
            <classname>PepperExporter</classname> inherit the super type
            <classname>PepperModule</classname>. So no matter of what kind of module you are going
        to implement, it must inherit one of the three named types. Figure <xref
            linkend="fig_pepperModule_classDiagram"/>shows this relation.<figure
            xml:id="fig_pepperModule_classDiagram">
            <title>class diagram showing the inheritance of Pepper module types</title>
            <mediaobject>
                <imageobject>
                    <imagedata width="500" fileref="images/pepperModule_classDiagram.png"/>
                </imageobject>
            </mediaobject>
        </figure> Now you might ask, what are the classes <classname>ModuleController</classname>
        and <classname>PepperMapper</classname> good for. The class
            <classname>ModuleController</classname> acts as a mediator between the Pepper framework
        and the concrete Pepper module. It initializes, starts and ends the modules processing. To
        explain the <classname>PepperMapper</classname> class, we want to give a short motivation:
        Since a mapping process can be relatively time consuming, we could increase the speed of
        mapping an entire corpus, if we are able to process mapping tasks simultaneously. Therefore
        we added mechanisms to run the process multi-threaded. Unfortunatly in Java multi-threading
        is not that trivial and the easiest way to do it is to separate each thread in an own class.
        This is where <classname>PepperMapper</classname> comes into game. A
            <classname>PepperModule</classname> object is a singleton instance for one step in the
        Pepper workflow and devides and distributes the tasks of mapping corpora and documents to
        several <classname>PepperModule</classname> objects. </para>
    <para>One step for a mapping in the Pepper workflow is not just a monolithic blog. It consists
        of several smaller conceptual aspects. Not each of the named aspects is essential, and some
        are belonging on the type of module you are implementing. Some are optional, some are
        recommanded and some are mandatory to implement. For a better XXXNachvollziehbarkeitXXXX,
        the rest of this section is structured according these aspects instead of the order of the code.<itemizedlist>
            <listitem>
                <para>mapping document-structure and corpus-structure [mandatory]</para>
            </listitem>
            <listitem>
                <para>analyzing an unknown corpus [recommanded, if module is an importer]</para>
            </listitem>
            <listitem>
                <para>im- and export corpus-structure [mandatory, if module is an im- or
                    exporter]</para>
            </listitem>
            <listitem>
                <para>customizing the mapping [recommanded]</para>
            </listitem>
            <listitem>
                <para>monitoring the progress [recommanded]</para>
            </listitem>
            <listitem>
                <para>prepare and clean-up [optional]</para>
            </listitem>
        </itemizedlist>The main aspect surely is the mapping of the document-structure and
        corpus-structure. This aspect deals with the creation, manipulation and export of Salt
        models. In this sense, the others are more sideaspects and not essential for the mapping
        itself, but important for the workflow.</para>
    <para>Some of the aspects are spread over several classes (PepperModule and PepperMapper) and
        methods. The single paragraphs mention which methods are involved. To get an overview of the
        entire method stack, figure <xref linkend="fig_pepperModule_sequenceDiagram"/> illustrates
        the communication between the framework, the <classname>PepperModule</classname> and
            <classname>PepperMapper</classname> class. <figure
            xml:id="fig_pepperModule_sequenceDiagram">
            <title>class diagram showing the inheritance of Pepper module types</title>
            <mediaobject>
                <imageobject>
                    <imagedata width="500" fileref="images/pepper_workflow.png"/>
                </imageobject>
            </mediaobject>
        </figure></para>
    <sect1 xml:id="sec_mapDocumentStructure">
        <title>Mapping document-structure and corpus-structure</title>
        <para>Mapping the document-structure, can mean to map one Salt model to another one, like a
            manipulator does, it can mean to import a document-structure like an importer does or,
            it can mean to export a document-structure like an exporter does. In this section, we
            describe the mechanism in Pepper of how to map a document-structure and meta data for
            corpora and documents. And which methods are needed to be overridden.</para>
        <para>Similar to the mapping of the corpus-structure, Pepper provides several levels where
            to intervene depending of how much the default behaviour matches your needs. </para>
        <sect2>
            <title>Default mechanism</title>
            <para>The easiest and maybe most beneficial way of creating a mapping is the use of the
                default mechanism, which means to derive the class
                    <classname>PepperMapper</classname>. This also enables you to run your module in
                multithreading mode without taking care of creating threads in Java. To register the
                    <classname>PepperMapper</classname> class create a method named
                    <methodname>createPepperMapper(SElementId sElementId)</methodname> returning
                your specific mapper object, for instance called MyMapper, see:
                <programlisting>public PepperMapper createPepperMapper(SElementId sElementId)
{ 
	MyMapper mapper= new MyMapper();
	return(mapper);
}</programlisting></para>
            <para>Let's start with the most important methods
                    <methodname>mapSDocument()</methodname> and
                    <methodname>mapSCorpus()</methodname>. <methodname>mapSDocument()</methodname>
                is the method to map the document-structure and is called by the framework for each
                    <classname>SDocument</classname> in <classname>SCorpusGraph</classname>. If this
                method is called, you can get the <classname>SDocument</classname> object to be
                imported, exported or manipulated by the method
                    <methodname>getSDocument()</methodname>. In case of you are implementing an im-
                or an exporter, you need to know the resource location to load or to store the data.
                This can be accessed via <methodname>getResourceURI()</methodname> and will return a
                uri pointing to the location of the resource. The same goes for the method
                    <methodname>mapSCorpus()</methodname>, but here the method
                    <methodname>getSDocument()</methodname> will return null. So call
                    <methodname>getSCorpus()</methodname> to get the current object to be
                manipulated. Often manipulating the <classname>SCorpus</classname> is necessary to
                add further meta-data, which were not be added during import phase of
                corpus-structure or to manipulate or export the meta-data. Both methods shall return
                a value determining the success of the mapping. Therefore the following three
                possible values are predefined <constant>MAPPING_RESULT.FINISHED</constant>,
                    <constant>MAPPING_RESULT.FAILED</constant> and
                    <constant>MAPPING_RESULT.DELETED</constant>. <itemizedlist>
                    <listitem>
                        <para>Finished means, that a document or corpus has been processed
                            successfully.</para>
                    </listitem>
                    <listitem>
                        <para>Failed means, that the corpus or document could not be processed
                            because of any kind of error.</para>
                    </listitem>
                    <listitem>
                        <para>Deleted means, that the document or corpus was deleted and shall not
                            be processed any further (by following modules).</para>
                    </listitem>
                </itemizedlist> In case, the mapping failed, the Pepper framework will print a
                warning, but proceed. The failed document will be not processed any further by
                following modules. </para>
            <para>If you need to do some initializations before the methods
                    <methodname>mapSDocument()</methodname> and or
                    <methodname>mapSCorpus()</methodname> are called, but after the constructor has
                been called, just override the method <methodname>initialize()</methodname> (see
                figure <!--<xref linkend="fig_pepperWorkflow"/>-->). This methods enables the
                possibility to make some initilizations depending on the values set by the
                framework.The general initialization, like setting the resource path and the
                    <classname>SDocument</classname> or <classname>SCorpus</classname> object to be
                manipulated is done by the framework itself. Here we show an excerpt of the
                    <classname>PepperMapper</classname>
                class.<programlisting>public class PepperMapperImpl implements PepperMapper {

    @Override
    protected void initialize(){
        //do some initilizations
    }
    
    @Override
    public MAPPING_RESULT mapSCorpus() {
    	//returns the resource in case that a module is an importer or exporter
       getResourceURI();
       //returns the SDocument object to be manipulated
       getSDocument();
       //returns that the process was successful
       return(MAPPING_RESULT.FINISHED);
    }
    
    @Override
    public MAPPING_RESULT mapSDocument() {
       //returns the resource in case that the module is an importer or exporter
       getResourceURI();
       //returns the SCorpus object to be manipulated
       getSCorpus();
       //returns that the process was successful
       return(MAPPING_RESULT.FINISHED);
    }
}
</programlisting>If
                you are using the default behaviour, you are done. Congratulations ;-).</para>
        </sect2>
        <sect2>
            <title>Deeper adoption level 2</title>
            <para>If you need more flexibility to adopt the mapping behaviour, you have to step into
                the mechanism on a deeper level. The class <classname>PepperModule</classname>
                specifies the <methodname>start(SElementId sElementId)</methodname>. In your module
                implementation, you can override that method. The following lines of code identifies
                whether the object to be processed is of type <classname>SDocument</classname> or
                    <classname>SCorpus</classname>.<programlisting>@Override
public void start(SElementId sElementId) throws PepperModuleException 
{
    if (sElementId.getSIdentifiableElement() instanceof SCorpus)
    {
    	//map for instance some meta-data
    }
    else if (sElementId.getSIdentifiableElement() instanceof SDocument)
    {
        //map the document-structure
    }
}</programlisting><note>
                    <para>Overriding the method <methodname>start(SElementId
                            sElementId)</methodname> does not enable multithreading automatically.
                        If you still want a multithreading processing, you will have to implement it
                        on your own.</para>
                </note><note>
                    <para>If you cannot use the default behaviour, please check the source code of
                        the <classname>PepperModule</classname> and
                            <classname>PepperImporter</classname>,
                            <classname>PepperManipulator</classname> or
                            <classname>PepperExporter</classname> depending on which kind of module
                        you are implementing. The sources will give you a more detailed view on
                        things need to be taken care of.</para>
                </note></para>
        </sect2>
        <sect2>
            <title>Deeper adoption level 3</title>
            <para> The class <classname>PepperModule</classname> further specifies the method
                    <methodname>start()</methodname>, which is the most generic method in terms of
                mapping and is directly called by the Pepper framework or more precisely spoken by
                the <classname>PepperModuleController</classname>. To access the
                    <classname>SDocument</classname> or <classname>SCorpus</classname>, you have to
                use the <classname>PepperModuleController</classname>, which can be accessed via
                    <methodname>getPepperModuleController()</methodname>. Each
                    <classname>PepperModule</classname> object has its own
                    <classname>PepperModuleController</classname> object working as a communicator
                between the <classname>PepperModule</classname> object and the Pepper framework.
                Since a <classname>PepperMoculeController</classname> object is connected to the
                    <classname>PepperModuleController</classname> object of the preceding and the
                following module, the objects to be processed (<classname>SDocument</classname> or
                    <classname>SCorpus</classname>) are exchanged via a queue to which both
                controllers have access. The module you are implementing can get the current
                    <classname>SElementId</classname> object via
                    <methodname>getPepperModuleController().get()</methodname>. But be advised, that
                this method will first return a result when the preceding module has processed its
                object. Until then the method will let your module wait. </para>
            <para><note>
                    <para>If you decided to not use the default behaviour, please check the source
                        code of the <classname>PepperModule</classname> and
                            <classname>PepperImporter</classname>,
                            <classname>PepperManipulator</classname> or
                            <classname>PepperExporter</classname> depending on which kind of module
                        you are implementing. The sources will give you a more detailed view on
                        things need to be taken care of.</para>
                </note>
            </para>
        </sect2>
    </sect1>

    <sect1 xml:id="sec_analyzing">
        <title>Analyzing an unknown corpus</title>
        <para>The experience has shown, that a lot of users, do not care a lot about formats and
            don't want to. Unfortunatly, in most cases it is not possible to not annoy the users
            with the details of a mapping. But we want to reduce the complexity for the user as much
            as possible. Since most users are not very interested, in the source format of a corpus,
            they just want to bring the corpus into any kind of tool to make further annotations or
            analysis. Therefore Pepper provides a possibility to automatically detect the source
            format of a corpus. Unfortunatly this task is very dependent of the format and the
            module processing the format. That makes the detection a task of the modules
            implementor. We are sorry. The mechanism of automatic detection is not a mandatory task,
            but it is very useful, which makes it recommended.</para>
        <para> The class <classname>PepperImporter</classname> defines the method
                <methodname>isImportable(URI corpusPath)</methodname> which can be overridden. The
            passed uri locates the entry point of the entire corpus as given in the Pepper workflow
            definition (so it points to the same location as
                <methodname>getCorpusDefinition().getCorpusPath()</methodname> does). Depending on
            the formats you want to support with your importer the detection can be very different.
            In the simplest case, it only is necessary, to search through the files at the given
            location (or to recursive traverse through directories, in case of the the location
            points to a directory), and to read their header section. For instance some formats like
            the xml formats PAULA (see: <link
                xlink:href="http://www.sfb632.uni-potsdam.de/en/paula.html"
                >http://www.sfb632.uni-potsdam.de/en/paula.html</link>) or TEI (see: <link
                xlink:href="http://www.tei-c.org/Guidelines/P5/"
                >http://www.tei-c.org/Guidelines/P5/</link>) starts with a header section like
            <programlisting>&lt;?xml version="1.0" standalone="no"?>
&lt;paula version="1.0">
&lt;!-- ... --></programlisting>
            or
            <programlisting>&lt;?xml version="1.0" encoding="UTF-8"?>
&lt;!-- ... -->
&lt;TEI xmlns="http://www.tei-c.org/ns/1.0">
&lt;!-- ... --></programlisting>.
            Formats where reading only the first lines will bring information about the format name
            and its version make automatic detection very easy. The method
                <methodname>isImportable(URI corpusPath)</methodname> shall return 1 if the corpus
            is importable by your importer, 0 if the corpus is not importable or a value between 0
            &lt; X &lt; 1, if no definitive answer is possible. The default implementation returns
            null, what means that the method is not overridden. This results in that the Pepper
            framework will ignore the module in automatic detection phase.</para>
    </sect1>
    <sect1 xml:id="sec_importCorpusStructure">
        <title>Im- and export corpus-structure</title>
        <para>The classes <classname>PepperImporter</classname> and
                <classname>PepperExporter</classname> provide automatic mechanism to im- or export
            the corpus-structure. This mechanism is adoptable step by step, according to your
            specific purpose. In many cases, the corpus-structure is simultaneous to the file
            structure of a corpus. Since many formats do not care about the corpus-structure, they
            only encode the document-strcuture. </para>
        <para>Pepper's default mapping maps the root folder (the direct <classname>URI</classname>
            location) to a root-corpus (<classname>SCorpus</classname> object). A sub-folder than
            corresponds to a sub-corpus (<classname>SCorpus</classname> object). The relation
            between super- and sub-corpus, is represented as a
                <classname>SCorpusRelation</classname> object. Following the assumption, that files
            contain the document-structure, there is one <classname>SDocument</classname>
            corresponding to each file in a sub-folder. The <classname>SCorpus</classname> and the
                <classname>SDocument</classname> object are linked with a
                <classname>SCorpusDocumentRelation</classname>. To get an impression of the
            described mapping, figure <xref linkend="fig_importCorpusStructure"/> shows a file
            structure and figure <xref linkend="fig_corpusStructure"/> shows the corresponding
            corpus-structure. <figure xml:id="fig_importCorpusStructure">
                <title>corpus-structure represented in file-structure</title>
                <mediaobject>
                    <imageobject>
                        <imagedata fileref="images/importCorpusStructure.png"/>
                    </imageobject>
                </mediaobject>
            </figure>
            <figure xml:id="fig_corpusStructure">
                <title>corpus-structure</title>
                <mediaobject>
                    <imageobject>
                        <imagedata width="299px" fileref="images/corpus-structure.png"/>
                    </imageobject>
                </mediaobject>
            </figure>Other formats do not encode the document-structure in just one file, they use a
            bunch of files instead. In that case the folder containing all the files (let's call it
            leaf-folder) corresponds to a <classname>SDocument</classname> object. Figure <xref
                linkend="fig_importCorpusStructure2"/> shows an example for these kind of
            file-structure, which corresponds also corresponds to the corpus-structure of figure
                <xref linkend="fig_corpusStructure"/>. <figure xml:id="fig_importCorpusStructure2">
                <title/>
                <mediaobject>
                    <imageobject>
                        <imagedata fileref="images/importCorpusStructure2.png"/>
                    </imageobject>
                </mediaobject>
            </figure>
        </para>
        <para> For keeping the correspondance between the corpus-structure and the file-structure,
            both the im- and the export of the corpus-structure make use of a map storing this
            correspondance. Corresponding to figure the corpus-structure of figure <xref
                linkend="fig_corpusStructure"/> and the file-structure of figure <xref
                linkend="fig_importCorpusStructure"/> table <xref linkend="selement_URI_map"/> shows
            the stored correletion between them. <table frame="all" xml:id="selement_URI_map">
                <title>map of <classname>SElementId</classname> and corresponding URI
                    locations</title>
                <tgroup cols="2" align="left" colsep="1" rowsep="1">
                    <tbody>
                        <row>
                            <entry>salt://corp1</entry>
                            <entry>/superCorpus</entry>
                        </row>
                        <row>
                            <entry>salt://corp1/subCorpus1</entry>
                            <entry>/superCorpus/subCorpus1</entry>
                        </row>
                        <row>
                            <entry>salt://corp1/subCorpus1#doc1</entry>
                            <entry>/superCorpus/subCorpus1/doc1.xml</entry>
                        </row>
                        <row>
                            <entry>salt://corp1/subCorpus1#doc2</entry>
                            <entry>/superCorpus/subCorpus1/doc2.xml</entry>
                        </row>
                        <row>
                            <entry>salt://corp1/subCorpus2</entry>
                            <entry>/superCorpus/subCorpus2</entry>
                        </row>
                        <row>
                            <entry>salt://corp1/subCorpus2#doc3</entry>
                            <entry>/superCorpus/subCorpus2/doc3.xml</entry>
                        </row>
                        <row>
                            <entry>salt://corp1/subCorpus2#doc4</entry>
                            <entry>/superCorpus/subCorpus2/doc4.xml</entry>
                        </row>
                    </tbody>
                </tgroup>
            </table>
        </para>
        <para> In the following two sections, we are going to describe the import and the export
            mechanism separatly. </para>
        <sect2>
            <title>Importing corpus-structure</title>
            <para>The default mechanism of importing a corpus-structure is implemented in the method
                <programlisting>importCorpusStructure(SCorpusGraph corpusGraph)</programlisting>.
                For a totally change of the default behavior just override this method. To adapt the
                behavior as described in the following, this has to be done before the method
                'importCorpusStructure' was called, so for instance in the constructor or in method
                <programlisting>isReadyToStart()</programlisting>. Back to figure <xref
                    linkend="fig_importCorpusStructure"/>, the import mechanism traverses the
                file-structure beginning at the super-folder via the sub-folders to the files and
                creates a <classname>SElementId</classname> object corresponding to each folder or
                file to fill the map of table <xref linkend="selement_URI_map"/>. This map is
                necessary for instance to retrieve the physical location of a document-structure
                during the mapping and can be accessed as shown in the following snippet:
                <programlisting>public PepperMapper createPepperMapper(SElementId sElementId){
    ...
    mapper.setResourceURI(getSElementId2ResourceTable().get(sElementId));
    ...
}</programlisting></para>
            <para>The import mechanism can be adapted by two parameters (or more precisly two
                lists). An ignore list containing file endings, which are supposed to be ignored
                during the import and a list of file ending which are supposed to be used for the import.<footnote>
                    <para>In case you are wondering, yes this sounds a bit strange, since each file
                        ending which is not contained in the second list won't be imported by
                        default. But there is an option, to set this to import each file, no matter
                        on the ending.</para>
                </footnote> Now let's show some code for adapting. The following snippet is placed
                into the method 'isReadyToStart()', but even could be located in inside the
                constructor:
                <programlisting>public boolean isReadyToStart(){
    ...
    //option 1
    getSDocumentEndings().add(PepperModule.ENDING_XML);
    getSDocumentEndings().add(PepperModule.ENDING_TAB);
    //option 2
    getSDocumentEndings().add(PepperModule.ENDING_ALL_FILES);
    getIgnoreEndings().add(PepperModule.ENDING_TXT)
    //option 3
    getSDocumentEndings().add(PepperModule.ENDING_LEAF_FOLDER);
    ...
}</programlisting></para>
            <para>In general the paramter of the method 'getSDocumentEndings()' is just a String,
                but there are some predefined ones you can use. The two lines marked as option 1,
                will add the endings 'xml' and 'tab' to the list of file endings to be imported.
                That means, that all files having one of these endings will be read and mapped to a
                document-structure. The first line of option 2, means to read each file, no matter
                on its ending. But the following line excludes all files having the ending 'txt'.
                Last but not least option 3 which is supposed to treat leaf-folders as
                document-structures and to create one <classname>SDocument</classname> object for
                each leaf-folder and not for each file, as mentioned in figure <xref
                    linkend="fig_importCorpusStructure2"/>.</para>
        </sect2>
        <sect2>
            <title>Exporting corpus-structure</title>
            <para>Similar to the import of the corpus-structure for the export, we provide a default
                behavior and possibilities for adaption. The export of the corpus-structure is
                handled in the method <programlisting>exportCorpusStructure()</programlisting>and
                invoked on top at the method 'start()' of the <classname>PepperExporter</classname>.
                For a totally change of the default behavior just override this method. The aim of
                this method is to fill the map between corpus-structure and file-structure (see
                table <xref linkend="selement_URI_map"/>). <note>
                    <para>The file-structure is automatically created, there are just URIs pointing
                        the virtual file or folder. The creation of the file or folder has to be
                        done by the Pepper module itself in method 'mapSCorpus()' or
                        'mapSDocument()'.</para>
                </note>To adapt the creation of this 'virtual' file-structure, you first have to
                choose the mode of export. You can do this for instance in method 'readyToStart()',
                as shown in the following snippet. But even in the constructor as
                well.<programlisting>public boolean isReadyToStart(){
    ...
    //option 1
    setExportMode(EXPORT_MODE.NO_EXPORT);
    //option 2
    setExportMode(EXPORT_MODE.CORPORA_ONLY);
    //option 3
    setExportMode(EXPORT_MODE.DOCUMENTS_IN_FILES);
    setSDocumentEnding(PepperModule.ENDING_TAB);
    ..
}</programlisting>In
                this snippet, option 1 means that no mapping will be created. Option 2 means that
                only <classname>SCorpus</classname> objects are mapped to a folder and
                    <classname>SDocument</classname> objects will be ignored. And option 3 means but
                that <classname>SCorpus</classname> objects are mapped to a folder and
                    <classname>SDocument</classname> objects are mapped to a file. The ending of that file can be determined by passing the ending
                to method 'setSDocumentEnding(String)'. In the given snippet a URI having the ending 'tab' is created for each <classname>SDocument</classname>.</para>
        </sect2>
    </sect1>
    <sect1 xml:id="sec_customization">
        <title>Customizing the mapping</title>
        <para> When creating a mapping, it is often a matter of choice to map some data this way or
            another. In such cases it might be clever not to be that strict and allow only one
            possiblity. It could be beneficially to leave this decision to the user. Customizing a
            mapping will increase the power of a Pepper module enormously, since it can be used for
            wider range of purposes without rewriting parts of it. The Pepper framework provides a
            property system to access such user customizations. Nevertheless, a Pepper module shall
            not be dependant on user customization. The past showed, that it is very frustrating for
            a user, when a Pepper module breaks up, because of not specifified properties. You
            should always define a default behaviour in case that the user has not specified one. </para>
        <sect2>
            <title>Property</title>
            <para>A property is just an attribute-value pair, consisting of a name so called
                property name and a value so called property value. Properties can be used for
                customizing the behaviour of a mapping of a Pepper module. Such a property must be
                specified by the user and determined in the Pepper workflow description. The Pepper
                framework will pass all customization properties directly to the instance of the
                Pepper module. </para>
            <note>
                <para>In the current version of Pepper, one has to specify a property file by its
                    location in the Pepper workflow description file (.pepperParams) in the
                    attribute @specialParams inside the &lt;importerParams&gt;,
                    &lt;exporterParams&gt; or &lt;moduleParams&gt; element. In the next versions
                    this will change to a possibility for adding properties directly to the Pepper
                    workflow description file.</para>
            </note>
        </sect2>
        <sect2>
            <title>Property registration</title>
            <para>The Pepper framework provides a registry mechanism to customize properties. This
                registry is called <classname>PepperModuleProperties</classname> and can be accessed
                via <methodname>getProperties()</methodname> and
                    <methodname>setProperties()</methodname>. This class only represents a container
                object for a set of <classname>PepperModuleProperty</classname> objects and provides
                accessing methods. An instance of <classname>PepperModuleProperty</classname>
                represents an abstract description of a property and the concrete value at once. In
                the registration phase it belongs to the tasks of a
                    <classname>PepperModule</classname> to specify the abstract description which
                consists of the name of the property, its datatype, a short description and a flag
                specifying whether this property is optional or mandatory. To create such an
                abstract description of a property use the constructor: <constructorsynopsis>
                    <methodname>PepperModuleProperty</methodname>
                    <methodparam>
                        <type>String</type>
                        <parameter>name</parameter>
                    </methodparam>
                    <methodparam>
                        <type>Class&gt;T&lt;</type>
                        <parameter>clazz</parameter>
                    </methodparam>
                    <methodparam>
                        <type>String</type>
                        <parameter>description</parameter>
                    </methodparam>
                    <methodparam>
                        <type>Boolean</type>
                        <parameter>required</parameter>
                    </methodparam>
                </constructorsynopsis> and pass the created property object to the property registry
                by calling the method <methodname>addProperty</methodname>. The Pepper framework
                uses the registry to first inform the user about usable properties for customization
                and second to fullfill the property objects with the property values set by the
                user. </para>
            <para>The value of a specific property can be accessed by passing its name to the
                registry. The method to be used is the following one: <methodsynopsis>
                    <methodname>getProperty</methodname>
                    <methodparam>
                        <type>String</type>
                        <parameter>propName</parameter>
                    </methodparam>
                </methodsynopsis>
            </para>
            <para>The easiest way of creating an own class for handling customization properties is
                to derive it from the provided class <classname>PepperModuleProperties</classname>.
                Imagine you want to register a property named 'MyProp' being of type String, which
                is mandatory to a property class called 'MyModuleProperties'. For having an easier
                access in your Pepper module, you can enhance the MyModuleProperties class with a
                getter method for property MyProp (see: getMyProp()).
                <programlisting>
//...
import de.hu_berlin.german.korpling.saltnpepper.pepper
    .pepperModules.PepperModuleProperties;
import de.hu_berlin.german.korpling.saltnpepper.pepper
    .pepperModules.PepperModuleProperty;
//...
public class MyModuleProperties extends PepperModuleProperties 
{
    //...            
    public MyModuleProperties()
	{  
	   //...
	   this.addProperty(new PepperModuleProperty&lt;String>
	       ("MyProp", String.class, "description of MyProp", true));
	   //...
	}
	//...
	public String getMyProp()
	{
		return((String)this.getProperty("MyProp").getValue());
	}
}
</programlisting>
            </para>
            <sect3>
                <title>Checking property constraints</title>
                <para>Since the value of a property can be required, you can check whether its value
                    is set by calling the method <methodname>checkProperties()</methodname>. To
                    customize the constraints of a property, you can override the method
                        <methodname>checkProperty(PepperModuleProperty&lt;?>)</methodname>. Imagine
                    a property named 'myProp' having a file as value, you might want to check its
                    existence. The following snippet shows the code how this could be done:
                    <programlisting>
public boolean checkProperty(PepperModuleProperty&lt;?> prop)
{
   //calls the check of constraints in parent, 
   //for instance if a required value is set
   super.checkProperty(prop);
   if ("myProp".equals(prop.getName()))
   {
       File file= (File)prop.getValue();
       //throws an exception, in case that the file does not exist
       if (!file.exists())
           throw new PepperModuleException("The file "+
           "set to property 'myProp' does not exist.");
   }
   return(true);
}
                    </programlisting>
                </para>
            </sect3>
            <sect3>
                <title>Initializing <classname>MyModuleProperties</classname></title>
                <para> Last but not least, you need to initialize your property object. The place
                    for best doing that is the constructor of your module. Such an early
                    initialization ensures, that the Pepper framework will use the correct object
                    and will not create a general <classname>PepperModuleProperties</classname>
                    object. Initialize your property object via calling: </para>
                <programlisting>this.setProperties(new MyModuleProperties());</programlisting>

            </sect3>
        </sect2>
    </sect1>
    <sect1 xml:id="sec_monitoring">
        <title>Monitoring the progress</title>
        <para> What could be more annoying than a not responding program and you do not know if it
            is still working or not? A conversion job could take some time, which is already
            frustrating enough for the user. Therefore we want to keep the frustration of users as
            small as possible and give him a precise response about the progress of the conversion
            job. </para>
        <para> Unfortunatly, although Pepper is providing a mechanism to make the monitoring of the
            progress as simple as possible, it remains the task of each module implementor. So you
            ;-). But don't get afraid, monitoring the progress just means the call of a single
            method in best case. </para>
        <para> If you are using the default mapping mechanism by implementing the class
                <classname>PepperMapper</classname>, this class provides the methods
                <methodname>addProgress(Double progress)</methodname> and
                <methodname>setProgress(Double progress)</methodname> for this purpose. Both methods
            have a different semantic. <methodname>addProgress(Double progress)</methodname> will
            add the passed value to the current progress, whereas <methodname>setProgress(Double
                progress)</methodname> will override the entire progress. The passed value for
            progress must be a value between 0 for 0% and 1 for 100%. It is up to you to call one of
            the methods in your code and to estimate the progress. Often it is easier not to
            estimate the time needed for the progress, than to divide the entire progress in several
            steps and to return a progress for each step. For instance the following sample
            separates the entire mapping process into five steps, which get the same rank of progress.<programlisting>//...
//map all STextualDS objects
addProgress(0.2);
//map all SToken objects
addProgress(0.2);
//map all SSpan objects
addProgress(0.2);
//map all SStruct objects
addProgress(0.2);
//map all SPointingRelation objects
addProgress(0.2);
//...</programlisting>
            <note>
                <para>When using <classname>PepperMapper</classname>, you only have to take care
                    about the progress of the current <classname>SDocument</classname> or
                        <classname>SCorpus</classname> object you are processing. The aggregation of
                    all currently processed objects (<classname>SDocument</classname> and
                        <classname>SCorpus</classname>) will be done automatically.</para>
            </note>
        </para>
        <para> In case that you do not want to use the default mechanism, you need to override the
            methods <methodname>getProgress(SElementId sDocumentId)</methodname> and
                <methodname>getProgress()</methodname> of your implementation of
                <classname>PepperModule</classname>.The method <methodname>getProgress(SElementId
                sDocumentId)</methodname> shall return the progress of the
                <classname>SDocument</classname> or <classname>SCorpus</classname> objects
            corresponding to the passed <classname>SElementId</classname>. Whereas the method
                <methodname>getProgress()</methodname> shall return the aggregated progress of all
                <classname>SDocument</classname> and <classname>SCorpus</classname> objects
            currently processed by your module. </para>
        <sect2>
            <title>Logging</title>
            <para>Another form of Monitoring is the logging, which could be used for passing
                messages to the user or passing messages to a file for debugging. The logging task
                in Pepper is handled by the SLF4J (see: <link xlink:href="http://www.slf4j.org/"
                    >http://www.slf4j.org/</link>). SLF4J is a logging framework, which provides an
                abstraction for several other logging frameworks like log4j (see: <link
                    xlink:href="http://logging.apache.org/log4j/2.x/"
                    >http://logging.apache.org/log4j/2.x/</link>) or java.util logging. Via creating
                a static logger object you can log several debug levels: trace, debug, info and
                error.
                <programlisting>private static final Logger logger= LoggerFactory.getLogger(SampleImporter.class);
logger.trace("messages for the implementor");
logger.debug("message for the implementor and user");
logger.info("messages for the user");
logger.error("messages in case of an exception");</programlisting></para>
        </sect2>
    </sect1>
    <sect1 xml:id="sec_cleanUp">
        <title>Prepare and clean-up</title>
        <itemizedlist>
            <listitem>
                <para>TODO: describe isReadyToRun()</para>
            </listitem>
        </itemizedlist>
        <para>Sometimes it might be necessary to make a clean up, after the module did the job. For
            instance when writing an im- or an exporter it might be necessary to close file streams,
            a db connection etc. Therefore, after all the processing is done, the Pepper framework
            calls the method <methodname>end()</methodname>. To run your clean up, just override it
            and your done. </para>
    </sect1>
</chapter>
