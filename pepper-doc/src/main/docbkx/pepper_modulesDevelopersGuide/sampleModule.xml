<?xml version="1.0" encoding="UTF-8"?>
<?xml-model href="http://docbook.org/xml/5.0/rng/docbook.rng" schematypens="http://relaxng.org/ns/structure/1.0"?>
<?xml-model href="http://docbook.org/xml/5.0/rng/docbook.rng" type="application/xml" schematypens="http://purl.oclc.org/dsdl/schematron"?>
<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink"
    version="5.0" xml:id="ch_sampleModule">
    <title>Adopting the SampleModules</title>
    <sect1>
        <title>Download the skeleton</title>
        <para> To start creating your own module for Pepper, please download the SampleModule, to
            be used as a skeleton for your own module. SampleModules is stored in our svn
            repository, therefore please export the project via an SVN client. The SVN location
            depends on the version you want to use and can be found at SampleModules (see: <link
                xlink:href="https://korpling.german.hu-berlin.de/svn/saltnpepper/PepperModules/SampleModules/tags"
                >https://korpling.german.hu-berlin.de/svn/saltnpepper/PepperModules/SampleModules/tags</link>).</para>
    </sect1>
    <sect1>
        <title>Adopting the project</title>
        <para> Here, we give a list of things to do to adapt the project to your needs. In some
            cases, the order of the entries is arbitrary, but in some cases it is easier to respect
            the given order. </para>
        <itemizedlist>
            <listitem>
                <para>Import the project as a Maven project (when working with Eclipse, use the
                    import option existing maven project, it might be that you have to install
                    further plugins or m2e connectors. So don't be scared if a dialog pops
                    up.)</para>
            </listitem>
            <listitem>
                <para>Rename the project to a name of your choice like 'pepperModules-MyModules'
                    (when working with Eclipse, right click on the project name and choose the menu
                    entry "Refactor" --> "Rename...")</para>
            </listitem>
            <listitem>
                <para>Rename the packages (when working with Eclipse, right click on the package
                    name and choose the menu entry "Refactor" --> "Rename...")</para>
            </listitem>
        </itemizedlist>
    </sect1>
    <sect1>
        <title>Adopting the pom.xml</title>
        <para>Maven follows the paradigm convention over configuration, therefore a lot of things
            are already predefined and do not need to be changed.</para>
        <para>But still, there are some things like the name of the project and so on, which are
            project specific and therefore have to be adopted. Just follow the given instructions to
            adopt the 'project object model' (pom). The items in the numbered list correspond to the
            TODO entries in the pom.xml file. You will find the pom.xml file in the parent directory
            of the SampleProject.</para>
        <orderedlist>
            <listitem>
                <para>Change the "groupId" to the name of your module (conventionally, the groupId
                    is the same as the package name). You will find the entry under
                    '/project/groupId'.</para>
            </listitem>
            <listitem>
                <para>Change the "artifactId" (to the module name). You will find the entry under
                    '/project/artifactId'.</para>
            </listitem>
            <listitem>
                <para>Modify the description: Write what the module is supposed to do. You will find
                    the entry under '/project/description'.</para>
            </listitem>
            <listitem>
                <para>Change the project homepage to the url of your project. You will find the
                    entry under '/project/url'.</para>
            </listitem>
            <listitem>
                <para>Change the issue tracker to the one you are using, in case that you do not use
                    any one, remove this entry. You will find the entry under
                    '/project/issueManagement'.</para>
            </listitem>
            <listitem>
                <para>Change the continuous integration management system to the one you are using,
                    in case that you do not use any one, remove this entry. You will find the entry
                    under '/project/ciManagement'.</para>
            </listitem>
            <listitem>
                <para>Change the inception year to the current year. You will find the entry under
                    '/project/inceptionYear'.</para>
            </listitem>
            <listitem>
                <para>Change the name of the organization to the one you are working for. You will
                    find the entry under '/project/organization'.</para>
            </listitem>
            <listitem>
                <para>Modify the scm information or remove them (the scm specifies the location of
                    your versioning repository like SVN, GIT, CVS etc.). You will find the entry
                    under '/project/scm'.</para>
            </listitem>
            <listitem>
                <para>Import needed maven dependencies (this is necessary to resolve dependencies to
                    libraries handled by maven). You will find the entry under
                    '/project/dependencies'.</para>
            </listitem>
            <listitem>
                <para>Change the connection to the tags folder of your scm, what you can see here is
                    the subversion connection for the pepperModules-SampleModules project. You will
                    find the entry under
                    '/project/build/plugins/plugin/configuration/tagBase'.</para>
            </listitem>
            <listitem>
                <para>Sometimes it is necessary to include libraries, which are not accessible via a
                    maven repository and therefore can not be resolved by maven. In that case we
                    recommend, to create a 'lib' folder in the project directory and to copy all the
                    libraries you need into it. Unfortunatly, you have register them twice, first
                    for maven and second for OSGi.</para>
                <para>To register such a library to maven, you need to install them to your local
                    maven repository. You can do that with:
                    <programlisting>
mvn install:install-file -Dfile=JAR_FILE -DgroupId=GROUP_ID -DartifactId=ARTIFACT_ID \
-Dversion=VERSION -Dpackaging=PACKAGING
                    </programlisting>
                    Now you need to add the library as a dependency to your pom. The following
                    snippet shows an example:
                    <programlisting>
&lt;dependency>
  &lt;groupId>GROUP_ID&lt;/groupId>
  &lt;artifactId>ARTIFACT_ID&lt;/artifactId>
  &lt;version>VERSION&lt;/version>
&lt;/dependency>
                    </programlisting>
                </para>
                <para>To make them accessible for OSGi, add them to the bundle-classpath of the
                    plugin named 'maven-bundle-plugin'. You will find the entry under
                    '/project/build/plugins/plugin[artifactId/text()=
                    'maven-bundle-plugin']/configuration/instructions/Bundle-ClassPath'. You further
                    need to add them to a second element named include-resource, which you will find
                    under '/project/build/plugins/plugin[artifactId/text()=
                    'maven-bundle-plugin']/configuration/instructions/Include-Resource'. The
                    following snippet gives an example:
                    <programlisting>&lt;Bundle-ClassPath>.,{maven-dependencies}, lib/myLib.jar&lt;/Bundle-ClassPath>
&lt;Include-Resource>{maven-resources}, LICENSE, NOTICE, 
lib/myLib.jar=lib/myLib.jar&lt;/Include-Resource>
                    </programlisting>
                    You include libraries not handled by maven, i.e. jar files, by setting the
                    bundle-path and extending the include-resources tag.
                    "/project/build/plugins/plugin[artifactId/text()=
                    'maven-bundle-plugin']/configuration/instructions/Include-Resource"</para>
            </listitem>
        </orderedlist>
    </sect1>
    <sect1>
        <title>Adopting the Java code</title>
        <para> This section describes how to customize the importer, manipulator or exporter.
            Therefore you will find in the <classname>SampleModule</classname> three classes named
                <classname>SampleImporter</classname>, <classname>SampleManipulator</classname> and
                <classname>SampleExporter</classname>. All of them are located in the package
                <package>de.hu_berlin.german.korpling.saltnpepper.pepperModules.sampleModules</package>.
            In most cases people do not want to create all of them sometimes people only want to
            create an importer an exporter or a manipulator. Then just delete the classes you won't
            implement. In case of you want to have several importers, manipulators or exporters,
            just copy the classes and proceed with each class as described in the following.
            Otherwise, you will end up with non-functional modules in your project.The items in the
            numbered list correspond to the TODO entries in the class files. <orderedlist>
                <listitem>
                    <para>Change the name of the component, for example use the format name and the
                        ending Importer or Exporter e.g. FORMATExporterComponent and
                        FORMATExporterComponentFactory, in case of you want to create a manipulator,
                        use a name describing the task e.g. MYTaskManipulatorComponent and
                        MYTaskManipulatorComponentFactory.</para>
                </listitem>
                <listitem>
                    <para>Change the name of the module, for example use the format name and the
                        ending Exporter (<classname>FORMATExporter</classname>).</para>
                </listitem>
                <listitem>
                    <para>In case that you are implementing an im- or exporter, change "sample" with
                        format name and 1.0 with the format version to be supported.</para>
                </listitem>
                <listitem>
                    <para>In case that you are creating an importer, override the method
                            <methodname>importCorpusStructure()</methodname> (see: <xref
                            linkend="sec_importCorpusStructure"/>), this method maps the corpus
                        structure of the given format to a corpus structure in Salt.</para>
                </listitem>
                <listitem>
                    <para>If you want to have a specific handling with the document strcutures,
                        override the method <methodname>start()</methodname>, for instance if you
                        want to use multithreading. Otherwise just delete this method or call
                            <methodname>super.start()</methodname>, than the method
                            <methodname>start(SElementId sElementId)</methodname> will be called for
                        each <classname>SDocument</classname> automatically.</para>
                </listitem>
                <listitem>
                    <para>Override the <methodname>method start(SElementId sElementId)</methodname>,
                        this is the point of mapping document structures between Salt and a format
                        or to place the functionality of a manipulator.</para>
                </listitem>
                <listitem>
                    <para>If you have to clean up (e.g. delete temporary files etc.), override the
                        method <methodname>end()</methodname>.</para>
                </listitem>
            </orderedlist>
        </para>
        <sect2 xml:id="sec_importCorpusStructure">
            <title><methodname>importCorpusStructure</methodname></title>
            <para> This method is supposed to create a corpus-structure in the Salt model which will
                be filled via the method <function>start()</function>. A corpus-structure consists
                of corpora (represented via the Salt element <classname>SCorpus</classname>),
                documents (represented represented via the Salt element
                    <classname>SDocument</classname>) and a linking between corpora and a corpus and
                a document (represented via the Salt element <classname>SCorpusRelation</classname>
                and <classname>SCorpDocRelation</classname>). Each corpus corpus can contain 0..*
                subcorpus and 0..* documents, but a corpus cannot contain both document and corpus.
                For more information, please take a look into the Salt User Guide. </para>
            <para>In many cases, the corpus structure is simulatneaus to the file structure of a
                corpus to import, since a lot of formats does not care about the corpus-structure.
                For that case, Pepper already provide a mechanism to more or less automatically
                create the corpus-structure. Here we give a short overview on that (for more
                details, please take a look into the JavaDoc).When mapping the file-structure to a
                corpus-structure the root folder (the direct <classname>URI</classname> location) is
                mapped into a root-corpus (<classname>SCorpus</classname> object) is created. For
                each sub-folder a sub-corpus (<classname>SCorpus</classname> object) is created. For
                each file for which the method <methodname>isFileToImport(URI, List)</methodname>
                returns <code>true</code>, a <classname>SDocument</classname> object is created and
                added to the current <classname>SCorpusGraph</classname> object. The objects are
                connected via <classname>SCorpusRelation</classname> or
                    <classname>SCorpusDocumentRelation</classname> objects. While traversing the
                file-structure, an <classname>SElementId</classname> object is created representing
                the corpus-hierarchy and added to the created <classname>SCorpus</classname> or
                    <classname>SDocument</classname> objects. A map of these
                    <classname>SElementId</classname> objects corresponding to the
                    <classname>URI</classname> objects is returned, so that in method
                    <methodname>start(SElementId)</methodname> this map can be used to identify the
                    <classname>URI</classname> location of the <classname>SDocument</classname>
                objects. </para>
            <note>
                <para>For a description of how to add entries to the file extension list, see
                        <methodname>isFileToImport(URI, List)</methodname>.</para>
            </note>
        </sect2>
        <sect2 xml:id="sec_isFileToImport">
            <title><methodname>isFileToImport</methodname></title>
            <para> This method returns whether a given <classname>URI</classname> object shall be
                imported during import phase. To customize the computation whether a file shall be
                imported or not, you can override the method
                <methodname>isFileToImport</methodname>.  This decision depends on the kind and the
                content of the given fileExtension list. The file extension list can contain a set
                of file extensions (Strings without '.') to be imported or marked as to be not
                imported (via the prefix
                    <varname>PepperImporter.NEGATIVE_FILE_EXTENSION_MARKER</varname>). The following
                list shows the condition of computation for returned value: <itemizedlist>
                    <listitem>
                        <para>This method returns false, in case that the given
                                <classname>URI</classname> object is null.</para>
                    </listitem>
                    <listitem>
                        <para>This method returns true for every <classname>URI</classname> object
                            in case that the list is null or empty.</para>
                    </listitem>
                    <listitem>
                        <para>This method returns true if the given list is a positive list (does
                            not contain the negative marker
                                <varname>PepperImporter.NEGATIVE_FILE_EXTENSION_MARKER</varname> at
                            all) and the file extension of the uri is contained in the list.</para>
                    </listitem>
                    <listitem>
                        <para>This method returns true if the given list is a negative list (any
                            item is prefixed with the negative marker
                                <varname>PepperImporter.NEGATIVE_FILE_EXTENSION_MARKER</varname>)
                            and the file extension of the uri is not contained in the list.</para>
                    </listitem>
                </itemizedlist>
                <note>
                    <para>When a list contains items prefixed with the negative marker and items
                        which are not, the list is interpreted as a negative list.</para>
                </note>
            </para>
            <para> In case that you want to customize the method by overriding it, but not losing
                its functionality, you can use the following lines of code:
                <programlisting>@Override
protected boolean isFileToImport(URI checkUri, List&lt;String&gt; fileExtensions)
{ 
    if (super.isFileToImport(checkUri))
    //TODO: do something, when super says yes
    else
    //TODO: do something, when super says no 
}</programlisting>
            </para>
        </sect2>
    </sect1>
    <sect1>
        <title>building the project</title>
        <para> We adopt the settings for using OSGi and to create Pepper modules, which are simply
            pluggable into the Pepper framework. So in the best case, you can just follow this
            guide, and run </para>
        <synopsis>
            mvn install assembly
        </synopsis>
        <para> and you will find a zip file in the target folder of your project
            (YOUR_PROJECT/target/distribution), which can simply plugged into Pepper via extracting
            its content to the plugin folder of Pepper (PEPPER_HOME/plugins). In the bad case some
            mean errors occur and you have to dig in a lot of online tutorials and forums and lose a
            lot of time. Please do not despair and write us an e-mail instead.
                <email>saltnpepper@lists.hu-berlin.de</email></para>
    </sect1>
</chapter>
