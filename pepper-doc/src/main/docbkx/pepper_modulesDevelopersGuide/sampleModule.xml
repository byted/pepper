<?xml version="1.0" encoding="UTF-8"?>
<?xml-model href="http://docbook.org/xml/5.0/rng/docbook.rng" schematypens="http://relaxng.org/ns/structure/1.0"?>
<?xml-model href="http://docbook.org/xml/5.0/rng/docbook.rng" type="application/xml" schematypens="http://purl.oclc.org/dsdl/schematron"?>
<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink"
    version="5.0" xml:id="ch_sampleModule">
    <title>Adopting the SampleModules</title>
    <sect1>
        <title>Download the skeleton</title>
        <para> To start creating your own module for Pepper, please download the SampleModule, to
            be used as a skeleton for your own module. SampleModules is stored in our svn
            repository, therefore please export the project via an SVN client. The SVN location
            depends on the version you want to use and can be found at SampleModules (see: <link
                xlink:href="https://korpling.german.hu-berlin.de/svn/saltnpepper/PepperModules/SampleModules/tags"
                >https://korpling.german.hu-berlin.de/svn/saltnpepper/PepperModules/SampleModules/tags</link>).</para>
    </sect1>
    <sect1>
        <title>Adopting the project</title>
        <para> Here, we give a list of things to do to adapt the project to your needs. In some
            cases, the order of the entries is arbitrary, but in some cases it is easier to respect
            the given order. </para>
        <itemizedlist>
            <listitem>
                <para>Import the project as a Maven project (when working with Eclipse, use the
                    import option existing maven project, it might be that you have to install
                    further plugins or m2e connectors. So don't be scared if a dialog pops
                    up.)</para>
            </listitem>
            <listitem>
                <para>Rename the project to a name of your choice like 'pepperModules-MyModules'
                    (when working with Eclipse, right click on the project name and choose the menu
                    entry "Refactor" --> "Rename...")</para>
            </listitem>
            <listitem>
                <para>Rename the packages (when working with Eclipse, right click on the package
                    name and choose the menu entry "Refactor" --> "Rename...")</para>
            </listitem>
        </itemizedlist>
    </sect1>
    <sect1>
        <title>Adopting the pom.xml</title>
        <para>Maven follows the paradigm convention over configuration, therefore a lot of things
            are already predefined and do not need to be changed.</para>
        <para>But still, there are some things like the name of the project and so on, which are
            project specific and therefore have to be adopted. Just follow the given instructions to
            adopt the 'project object model' (pom). The items in the numbered list correspond to the
            TODO entries in the pom.xml file. You will find the pom.xml file in the parent directory
            of the SampleProject.</para>
        <orderedlist>
            <listitem>
                <para>Change the "groupId" to the name of your module (conventionally, the groupId
                    is the same as the package name). You will find the entry under
                    '/project/groupId'.</para>
            </listitem>
            <listitem>
                <para>Change the "artifactId" (to the module name). You will find the entry under
                    '/project/artifactId'.</para>
            </listitem>
            <listitem>
                <para>Modify the description: Write what the module is supposed to do. You will find
                    the entry under '/project/description'.</para>
            </listitem>
            <listitem>
                <para>Change the project homepage to the url of your project. You will find the
                    entry under '/project/url'.</para>
            </listitem>
            <listitem>
                <para>Change the issue tracker to the one you are using, in case that you do not use
                    any one, remove this entry. You will find the entry under
                    '/project/issueManagement'.</para>
            </listitem>
            <listitem>
                <para>Change the continuous integration management system to the one you are using,
                    in case that you do not use any one, remove this entry. You will find the entry
                    under '/project/ciManagement'.</para>
            </listitem>
            <listitem>
                <para>Change the inception year to the current year. You will find the entry under
                    '/project/inceptionYear'.</para>
            </listitem>
            <listitem>
                <para>Change the name of the organization to the one you are working for. You will
                    find the entry under '/project/organization'.</para>
            </listitem>
            <listitem>
                <para>Modify the scm information or remove them (the scm specifies the location of
                    your versioning repository like SVN, GIT, CVS etc.). You will find the entry
                    under '/project/scm'.</para>
            </listitem>
            <listitem>
                <para>Import needed maven dependencies (this is necessary to resolve dependencies to
                    libraries handled by maven). You will find the entry under
                    '/project/dependencies'.</para>
            </listitem>
            <listitem>
                <para>Change the connection to the tags folder of your scm, what you can see here is
                    the subversion connection for the pepperModules-SampleModules project. You will
                    find the entry under
                    '/project/build/plugins/plugin/configuration/tagBase'.</para>
            </listitem>
            <listitem>
                <para>Sometimes it is necessary to include libraries, which are not accessible via a
                    maven repository and therefore can not be resolved by maven. In that case we
                    recommend, to create a 'lib' folder in the project directory and to copy all the
                    libraries you need into it. Unfortunatly, you have register them twice, first
                    for maven and second for OSGi.</para>
                <para>To register such a library to maven, you need to install them to your local
                    maven repository. You can do that with:
                    <programlisting>
mvn install:install-file -Dfile=JAR_FILE -DgroupId=GROUP_ID -DartifactId=ARTIFACT_ID \
-Dversion=VERSION -Dpackaging=PACKAGING
                    </programlisting>
                    Now you need to add the library as a dependency to your pom. The following
                    snippet shows an example:
                    <programlisting>
&lt;dependency>
  &lt;groupId>GROUP_ID&lt;/groupId>
  &lt;artifactId>ARTIFACT_ID&lt;/artifactId>
  &lt;version>VERSION&lt;/version>
&lt;/dependency>
                    </programlisting>
                </para>
                <para>To make them accessible for OSGi, add them to the bundle-classpath of the
                    plugin named 'maven-bundle-plugin'. You will find the entry under
                    '/project/build/plugins/plugin[artifactId/text()=
                    'maven-bundle-plugin']/configuration/instructions/Bundle-ClassPath'. You further
                    need to add them to a second element named include-resource, which you will find
                    under '/project/build/plugins/plugin[artifactId/text()=
                    'maven-bundle-plugin']/configuration/instructions/Include-Resource'. The
                    following snippet gives an example:
                    <programlisting>&lt;Bundle-ClassPath>.,{maven-dependencies}, lib/myLib.jar&lt;/Bundle-ClassPath>
&lt;Include-Resource>{maven-resources}, LICENSE, NOTICE, 
lib/myLib.jar=lib/myLib.jar&lt;/Include-Resource>
                    </programlisting>
                    You include libraries not handled by maven, i.e. jar files, by setting the
                    bundle-path and extending the include-resources tag.
                    "/project/build/plugins/plugin[artifactId/text()=
                    'maven-bundle-plugin']/configuration/instructions/Include-Resource"</para>
            </listitem>
        </orderedlist>
    </sect1>
    <sect1>
        <title>Adopting the Java code</title>
        <para> This section describes how to customize the importer, manipulator or exporter.
            Therefore you will find in the <classname>SampleModule</classname> three classes named
                <classname>SampleImporter</classname>, <classname>SampleManipulator</classname> and
                <classname>SampleExporter</classname>. All of them are located in the package
                <package>de.hu_berlin.german.korpling.saltnpepper.pepperModules.sampleModules</package>.
            In most cases people do not want to create all of them sometimes people only want to
            create an importer an exporter or a manipulator. Then just delete the classes you won't
            implement. In case of you want to have several importers, manipulators or exporters,
            just copy the classes and proceed with each class as described in the following.
            Otherwise, you will end up with non-functional modules in your project. The items in the
            numbered list correspond to the TODO entries in the class files. <orderedlist>
                <listitem>
                    <para>Change the name of the component, for example use the format name and the
                        ending Importer or Exporter e.g. FORMATExporterComponent and
                        FORMATExporterComponentFactory, in case of you want to create a manipulator,
                        use a name describing the task e.g. MYTaskManipulatorComponent and
                        MYTaskManipulatorComponentFactory.</para>
                </listitem>
                <listitem>
                    <para>Change the name of the module, for example use the format name and the
                        ending Exporter (<classname>FORMATExporter</classname>).</para>
                </listitem>
                <listitem>
                    <para>In case that you are implementing an im- or exporter, change "sample" with
                        format name and 1.0 with the format version to be supported.</para>
                </listitem>
                <listitem>
                    <para>In case that you are creating an importer, check if the default behavior
                        of the corpus-structure import mechanism fits for your need. For tfurther
                        details, see: <xref linkend="sec_importCorpusStructure"/>.</para>
                </listitem>
                <listitem>
                    <para>If you want to have a specific handling with the document strcutures,
                        override the method <methodname>start()</methodname>, for instance if you
                        want to use multithreading. Otherwise just delete this method or call
                            <methodname>super.start()</methodname>, than the method
                            <methodname>start(SElementId sElementId)</methodname> will be called for
                        each <classname>SDocument</classname> automatically.</para>
                </listitem>
                <listitem>
                    <para>Override the <methodname>method start(SElementId sElementId)</methodname>,
                        this is the point of mapping document structures between Salt and a format
                        or to place the functionality of a manipulator.</para>
                </listitem>
                <listitem>
                    <para>If you have to clean up (e.g. delete temporary files etc.), override the
                        method <methodname>end()</methodname>.</para>
                </listitem>
            </orderedlist>
            The following sections will give a brief overview to the single items. For a more detailed view, please take a look into the corresponding JavaDoc.
        </para>
        <sect2 xml:id="sec_importCorpusStructure">
            <title>Importing the corpus-structure</title>
            <para> A corpus-structure consists of corpora (represented via the Salt element
                    <classname>SCorpus</classname>), documents (represented represented via the Salt
                element <classname>SDocument</classname>), a linking between corpora and a linking
                between a corpus and a document (represented via the Salt element
                    <classname>SCorpusRelation</classname> and
                    <classname>SCorpDocRelation</classname>). Each corpus can contain 0..* subcorpus
                and 0..* documents, but a corpus cannot contain both document and corpus. For more
                information, please take a look into the Salt User Guide. </para>
            <para>The general class <classname>PepperImporter</classname> provides an adoptable and
                automatical mechanism to create a corpus-structure. This mechanism is adoptable step
                by step, according to your specific purpose. In many cases, the corpus structure is
                simulatneaus to the file structure of a corpus. Since many formats does not care
                about the corpus-structure, they only encode the document-strcuture. </para>
            <para>Peppers default mapping maps the root folder (the direct
                    <classname>URI</classname> location) into a root-corpus
                    (<classname>SCorpus</classname> object). For each sub-folder a sub-corpus
                    (<classname>SCorpus</classname> object) is created and added to the
                    <classname>SCorpusGraph</classname>. For each super- and sub-corpus relation, a
                <classname>SCorpusRelation</classname> object is created. For each interesting<footnote><para>
                    interesting here means, a file whichs ending is registered in a collection (see: <methodname>getSDocumentEndings()</methodname>)
                </para></footnote>
                file a <classname>SDocument</classname> object is created and added to the current
                    <classname>SCorpusGraph</classname> object. The <classname>SCorpus</classname>
                and <classname>SDocument</classname> objects are connected via a
                    <classname>SCorpusDocumentRelation</classname> object. While traversing the
                file-structure, an <classname>SElementId</classname> object is created representing
                the corpus-hierarchy and added to the created <classname>SCorpus</classname> or
                    <classname>SDocument</classname> object. A map of these
                    <classname>SElementId</classname> objects corresponding to the
                    <classname>URI</classname> objects is returned, so that in method
                    <methodname>start(SElementId)</methodname> this map can be used to identify the
                    <classname>URI</classname> location of the <classname>SDocument</classname>
                objects. </para>
            <para>To customize the default behaviour, Pepper provides three steps ascending in their
                implementation efforts: <orderedlist>
                    <listitem>
                        <para>Adopting the one or more of the collections:
                                <classname>sDocumentEndings</classname>,
                                <classname>sCorpusEndings</classname> or
                                <classname>ignoreEndings</classname>, accessible via the methods
                                <methodname>getSDocumentEndings</methodname>,
                                <methodname>getSCorpusEndings</methodname> and
                                <methodname>getIgnoreEndings</methodname>. To
                                <classname>sDocumentEndings</classname>you can add all endings of
                            files, containing the document-structure (you can even add a value for
                            leaf folders <classname>ENDING_LEAF_FOLDER</classname>). To
                                <classname>sCorpusEndings</classname> you can add all endings of
                            files, containing data for the corpus-structure (the value
                                <classname>ENDING_FOLDER</classname> for folders is set by default).
                            And to <classname>ignoreEndings</classname> you can add all endings of
                            files, to be ignored for the import process.</para>
                        <para>Lets give an example: <figure xml:id="fig_importCorpusStructure">
                                <title/>
                                <mediaobject>
                                    <imageobject>
                                        <imagedata fileref="images/importCorpusStructure.png"/>
                                    </imageobject>
                                </mediaobject>
                            </figure> To map this structure, you just have to add the ending 'xml'
                            to the collection <classname>sDocumentEndings</classname>, you can do
                            this using the constant <classname>ENDING_XML</classname> (even others
                            are predefined). </para>
                        <para>To give another example, the following file-structure will result in
                            the same corpus-structure, when setting the collection
                                <classname>sDocumentEndings</classname> to the value
                                <classname>ENDING_LEAF_FOLDER</classname>. <figure
                                xml:id="fig_importCorpusStructure2">
                                <title/>
                                <mediaobject>
                                    <imageobject>
                                        <imagedata fileref="images/importCorpusStructure2.png"/>
                                    </imageobject>
                                </mediaobject>
                            </figure>
                        </para>
                        <para>You can do the collection adoptions anywhere you want to, but make
                            sure, that they have to be done, before the method
                                <methodname>importCorpusStructure</methodname> was called by the
                            framework. A good location for instance is the constructor:
                            <programlisting>
public MyImporter()
{
  ...
  this.getSDocumentEndings().add(PepperImporter.ENDING_LEAF_FOLDER);
  ...
}
                        </programlisting></para>
                    </listitem>
                    <listitem>
                        <para>If the previous step does not fully fit your needs, Pepper uses a
                            callback mechanism which can be overridden. Using the method
                                <methodname>setTypeOfResource</methodname> Pepper checks for each
                            resource (folder and pure file) whether it represents a
                                <classname>SDocument</classname> or a <classname>SCorpus</classname>
                            object. The origin implementation therefore uses the above mentioned
                            collections. If adopting these collections does not fullfill your
                            specific purpose, you can override it with a more complex
                            behavior.</para>
                    </listitem>
                    <listitem>
                        <para>The last opportunity to adopt the behavior is to override the methode
                                <classname>importCorpusStructure</classname>. This is the main
                            method called by the Pepper framework. This method must generate a map
                            containing the correspondence between a
                                <classname>SElementId</classname> (representing a
                                <classname>SDocument</classname> or a <classname>SCorpus</classname>
                            object) and a resource. For instance, remember the sample of <xref
                                linkend="fig_importCorpusStructure"/>, this could result in the
                            following map: <table frame="all">
                                <title/>
                                <tgroup cols="2" align="left" colsep="1" rowsep="1">
                                    <tbody>
                                        <row>
                                            <entry>salt://corp1</entry>
                                            <entry>/superCorpus</entry>
                                        </row>
                                        <row>
                                            <entry>salt://corp1/subCorpus1</entry>
                                            <entry>/superCorpus/subCorpus1</entry>
                                        </row>
                                        <row>
                                            <entry>salt://corp1/subCorpus1#doc1</entry>
                                            <entry>/superCorpus/subCorpus1/doc1.xml</entry>
                                        </row>
                                        <row>
                                            <entry>salt://corp1/subCorpus1#doc2</entry>
                                            <entry>/superCorpus/subCorpus1/doc2.xml</entry>
                                        </row>
                                        <row>
                                            <entry>salt://corp1/subCorpus2</entry>
                                            <entry>/superCorpus/subCorpus2</entry>
                                        </row>
                                        <row>
                                            <entry>salt://corp1/subCorpus2#doc3</entry>
                                            <entry>/superCorpus/subCorpus2/doc3.xml</entry>
                                        </row>
                                        <row>
                                            <entry>salt://corp1/subCorpus2#doc4</entry>
                                            <entry>/superCorpus/subCorpus2/doc4.xml</entry>
                                        </row>
                                    </tbody>
                                </tgroup>
                            </table>
                        </para>
                    </listitem>
                </orderedlist> Later on, this map is used when importing the document-structure, to
                locate the content of a <classname>SDocument</classname> object.</para>
        </sect2>
        <sect2 xml:id="sec_mapDocumentStructure">
            <title>Mapping the document-structure</title>
            <para>Mapping the document-structure, can mean to map one Salt model to another one, like a manipulator does, it can mean to import a document-structure like an importer does or to export a document-structure like an exporter does. 
            </para>
            <orderedlist>
                <listitem><para>What is document structure</para></listitem>
                <listitem><para>even corpus-structure can be processed (manipulated, infos can be added etc.)</para></listitem>
                <listitem><para>core of mapping, importing, exporting</para></listitem>
                <listitem><para>what is multithreading, for what is it good for, Pepper tries to keep it simple for you, explain step mechanism first Mapper, second start(SElementId), third start() (same procedure as import coprus structure (first easy done adoptions, than the more complex ones and so on.))</para></listitem>                
            </orderedlist>
        </sect2>
        <sect2 xml:id="sec_cleanUp">
            <title>Cleaning up after all</title>
            <para>Sometimes it might be necessary to make a clean up, after module did the job. For instance when writing an im- or an exporter it might be necessary to close file streams or a db connection. Therefore, after all the processing was done, the Pepper framework calls the method <methodname>end</methodname>. To run your clean up, just override it and your done. 
            </para>
        </sect2>
        <sect2 xml:id="sec_monitoring">
            <title>Monitoring the progress</title>
            <para>
                <itemizedlist>
                    <listitem><para>annoying, but very valuable, pepepr keeps the user informed, aout the conversion progress</para></listitem>
                    <listitem><para>which method to be used</para></listitem>
                    <listitem><para>just compute it for one document, the rest is done by pepper, is it???</para></listitem>
                </itemizedlist>
            </para>
        </sect2>
        <sect2 xml:id="sec_analyzing">
            <title>Analyzing the unknown</title>
            <para>
                <itemizedlist>
                    <listitem><para>Pepper provides a mechanism to detect if an importer applicable to a given unknown format</para></listitem>
                    <listitem><para>Not a must, but very helpful to the user, so if he don't care about formats, he still can convert his corpus</para></listitem>
                    <listitem><para>which method to be used and what is the main (very simple) idea (just read first lines of format)</para></listitem>
                </itemizedlist>
            </para>
        </sect2>
    </sect1>
    <sect1>
        <title>building the project</title>
        <para> We adopt the settings for using OSGi and to create Pepper modules, which are simply
            pluggable into the Pepper framework. So in the best case, you can just follow this
            guide, and run </para>
        <synopsis>
            mvn install assembly
        </synopsis>
        <para> and you will find a zip file in the target folder of your project
            (YOUR_PROJECT/target/distribution), which can simply plugged into Pepper via extracting
            its content to the plugin folder of Pepper (PEPPER_HOME/plugins). In the bad case some
            mean errors occur and you have to dig in a lot of online tutorials and forums and lose a
            lot of time. Please do not despair and write us an e-mail instead.
                <email>saltnpepper@lists.hu-berlin.de</email></para>
    </sect1>
</chapter>
