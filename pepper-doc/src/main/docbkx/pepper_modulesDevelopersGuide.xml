<?xml version="1.0" encoding="UTF-8"?>
<?xml-model href="http://www.oasis-open.org/docbook/xml/5.0/rng/docbook.rng" schematypens="http://relaxng.org/ns/structure/1.0"?>
<book xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.0">
    <info>
        <title>Pepper</title>
        <subtitle>Developer's Guide for PepperModules</subtitle>
        <authorgroup>
            <author>
                <personname>
                    <firstname>Florian</firstname>
                    <surname>Zipser</surname>
                </personname>
                <email>saltnpepper@lists.hu-berlin.de</email>
            </author>
            <author>
                <orgname xml:id="org1">INRIA</orgname>
            </author>
            <author>
                <orgname xml:id="org2">SFB 632 Information Structure / D1 Linguistic
                    Database</orgname>
            </author>
            <author>
                <orgname xml:id="org3">Humboldt-Universität zu Berlin</orgname>
            </author>
            <author>
                <orgname xml:id="org4">Universität Potsdam</orgname>
            </author>
        </authorgroup>
        <copyright>
            <year>2012</year>
            <holder><xref linkend="org1"/>, <xref linkend="org2"/>, <xref linkend="org3"/>, <xref
                    linkend="org1"/>,<xref linkend="org4"/>, All rights reserved.</holder>
        </copyright>
        <releaseinfo>Version ${project.version}</releaseinfo>
    </info>
    <preface>
        <title>Foreword</title>
        <para>The aim of this document is to provide a helpful guide to create own PepperModules to
            plug them into the pepper framework. Currently this document is not in a very good state
            so far. It is not more than a loose collection of hopefully interesting information for
            developers. But are working on it, to fullfill its aim and to make a helpfull and
            readable guide out of it. You are very welcome to help us improving this document by
            reporting us bugs, requests for more information or by writing sections. Please write an
            email to <email>saltnpepper@lists.hu-berlin.de</email>.</para>
    </preface>
    <chapter>
        <title>Introduction</title>
        <para>Since Pepper is a plugable framework, we used an underlying framework called OSGi
            (see: <link xlink:href="http://www.osgi.org/">http://www.osgi.org/</link>) providing
            such a functiuonality. OSGi is a mighty framework and has a lot of impact in the way of
            programming things in java. Because we do not want to force you to learn OSGi, when you
            just want to create a new module for pepper, we tried to hide the OSGi layer as good as
            possible. Therefore and for the lifecycle management of such projects, we used another
            framework called maven (see: <link xlink:href="http://maven.apache.org/"
                >http://maven.apache.org/</link>). Maven is configured via an xml file called
            pom.xml, you will find it in all SaltNPepper projects and also in the root of the
            SampleModule project. Maven makes things easier for use especially in dealing with
            dependencies. For working with maven please install the program from <link
                xlink:href="http://maven.apache.org/">http://maven.apache.org/</link> (where are
            acutually using version 3.0.3). Most Java IDEs provide a support for maven like Eclipse
            (see: <link xlink:href="www.eclipse.org/">www.eclipse.org/</link>) or NetBeans (see:
                <link xlink:href="www.netbeans.org/">www.netbeans.org/</link>). Maven follows the
            paradigm convention over configuration, therefore a lot of things are already
            predefined. We adopt the settings for using OSGi and to create PepperModules, which are
            simply plugable into the Pepper framework. So in the the good case, you can just follow
            this guide, and run </para>
        <synopsis>
            mvn install assembly
        </synopsis>
        <para> and you will find a zip file in the target folder of your project
            (YOUR_PROJECT/target/distribution), which can simply pluged into Pepper via extracting
            its content to the plugin folder of Pepper. In the bad case some mean errors occur and
            you have to dig in a lot of online tutorials and forums and lose a lot of time. Please
            do not despair and write us an e-mail instead.
                <email>saltnpepper@lists.hu-berlin.de</email>
        </para>
        <para> We are trying to make things as easy to use as possible, but we are an non profit
            project and we need your help. So please tell us if things are to difficult and help us
            improving the framework. </para>
        <para> Have fun developing with SaltNPepper!</para>
        <sect1>
            <title>Download the skeleton</title>
            <para> To start with creating an own module for Pepper, please download the
                SampleModule, to be used as a skeleton for your own module. SampleModules is stored
                in our svn repository, therefore please export the project via an SVN client. The
                SVN location depends on the version you want to use and can be found at
                SampleModules. </para>
        </sect1>
    </chapter>
    <chapter>
        <title>Adopting the SampleModules</title>
        <para> Before we start adapting the modules, please think about what kinds of modules you
            want to provide in your project. If you just want to implement an importer, delete the
            exporter and manipulator code from the SampleModule. Otherwise, you will end up with
            non-functional modules in your project. </para>
        <para> Here, we give a list of things to do to adapt the project to your needs. In some
            cases, the order of the entries is arbitrary, but in some cases it is easier to respect
            the given order. </para>
        <sect1>
            <title>Adopting the project</title>
            <itemizedlist>
                <listitem>
                    <para>import the project as a Maven project (when working with eclipse, use the
                        import option existing maven project)</para>
                </listitem>
                <listitem>
                    <para>rename the project (when working with eclipse, right click on the project
                        name and choose the menu entry refactor --> rename)</para>
                </listitem>
                <listitem>
                    <para>rename the package (when working with eclipse, right click on the package
                        name and choose the menu entry refactor --> rename)</para>
                </listitem>
            </itemizedlist>
        </sect1>
        <sect1>
            <title>Adopting the pom.xml</title>
            <para>The items in the numbered list correspond to the TODO entries in the pom.xml file.
                You will find the pom.xml file in the parent directory of the SampleProject.</para>
            <itemizedlist>
                <listitem>
                    <para>change the groupId to the name of your module (conventionally, the groupId
                        is the same as the package name)</para>
                </listitem>
                <listitem>
                    <para>change the artifactId (to the module name)</para>
                </listitem>
                <listitem>
                    <para>modify the description: Write what the module is supposed to do</para>
                </listitem>
                <listitem>
                    <para>change the project homepage to the url of your project</para>
                </listitem>
                <listitem>
                    <para>change the issue tracker to the one you are using, in case of you do not
                        use any one, remove this entry</para>
                </listitem>
                <listitem>
                    <para>change the continuous integration management system to the one you are
                        using, in case of you do not use any one, remove this entry</para>
                </listitem>
                <listitem>
                    <para>change the inception year to the current year</para>
                </listitem>
                <listitem>
                    <para>change the name of the organization to the one you are working for</para>
                </listitem>
                <listitem>
                    <para>modify the scm information or remove them (the scm specifies the location
                        of your module's SVN repository)</para>
                </listitem>
                <listitem>
                    <para>import needed maven dependencies (this is necessary to resolve
                        dependencies to libraries handled by maven)</para>
                </listitem>
                <listitem>
                    <para>change the connection to the tags folder of your scm, what you can see
                        here is the subversion connection for the pepperModules-SampleModules
                        project</para>
                </listitem>
                <listitem>
                    <para>include libraries not handled by maven, i.e. jar files, by setting the
                        bundle-path and extending the include-resources tag.</para>
                </listitem>
            </itemizedlist>
        </sect1>
        <sect1>
            <title>Adopting the Java code</title>
            <para> This section describes how to customize the importer, manipulator or exporter.
                Therefore you will find in the <classname>SampleModule</classname> three classes
                named <classname>SampleImporter</classname>,
                    <classname>SampleManipulator</classname> and
                    <classname>SampleExporter</classname>. All of them are located in the package
                    <package>de.hu_berlin.german.korpling.saltnpepper.pepperModules.sampleModules</package>.
                In most cases people do not want to create all of them sometimes people only want to
                create an importer an exporter or a manipulator. Then just delete the classes you
                won't implement, In case of you want to have several importer, manipulators or
                exporters, just copy the classes and proceed with each class as described in the
                following. The items in the numbered list correspond to the TODO entries in the
                class files. <itemizedlist>
                    <listitem>
                        <para>change the name of the component, for example use the format name and
                            the ending Importer or Exporter e.g. FORMATExporterComponent and
                            FORMATExporterComponentFactory, in case of you want to create a
                            manipulator, use a name describing the task e.g.
                            MYTaskManipulatorComponent and MYTaskManipulatorComponentFactory</para>
                    </listitem>
                    <listitem>
                        <para>change the name of the module, for example use the format name and the
                            ending Exporter (<classname>FORMATExporter</classname>)</para>
                    </listitem>
                    <listitem>
                        <para>in case of you are implementing an im- or exporter, change "sample"
                            with format name and 1.0 with format version to support</para>
                    </listitem>
                    <listitem>
                        <para>in case of you are creating an importer, override the method
                                <methodname>importCorpusStructure()</methodname>, this method maps
                            the corpus structure of the given format to a corpus structure in
                            Salt</para>
                    </listitem>
                    <listitem>
                        <para>if you want to have a specific handling with the document strcuture,
                            override the method <methodname>start()</methodname>, for instance if
                            you want to have athreading. Otherwise just delete this method or call
                                <methodname>super.start()</methodname>, than the method
                                <methodname>start(SElementId sElementId)</methodname> will be called
                            for each <classname>SDocument</classname> automatically.</para>
                    </listitem>
                    <listitem>
                        <para>Override the <methodname>method start(SElementId
                                sElementId)</methodname>, this is the point of mapping
                            documentstructures between Salt and a format or to place the
                            functionality of a manipulator</para>
                    </listitem>
                    <listitem>
                        <para>If some clean ups left, override the method
                                <methodname>end()</methodname></para>
                    </listitem>
                </itemizedlist>
            </para>
            <sect2>
                <title><methodname>importCorpusStructure</methodname></title>
                <itemizedlist>
                    <listitem><para> imports corpus structure, into a <classname>SCorpusGraph</classname>, means creates a
                            structure consisting of <classname>SDocument</classname> and
                                <classname>SCorpus</classname> node objects and
                                <classname>SCorpusRelation</classname> and
                                <classname>SCorpDocRelation</classname> relation objects connecting
                            them.</para></listitem>
                    <listitem><para> corpus structure super and sub corpus, a corpus can contain 0..* subcorpus and
                    0..* documents, a corpus not contain both document and corpus</para></listitem>
                    <listitem><para>creates a table
                        document-id to uri for method <methodname>start()</methodname></para></listitem>
                    <listitem><para>method
                        <methodname>isFileToImport()</methodname> does following and can be
                        overridden</para></listitem>
                </itemizedlist>
                <para> Computes a corpus-structure given by the file-structure located by the
                    address of the given <classname>URI</classname> object. For the root folder (the
                    direct <classname>URI</classname> location) a root-corpus
                        (<classname>SCorpus</classname> object) is created. For each sub-folder a
                    sub-corpus (<classname>SCorpus</classname> object) is created. For each file for
                    which the method <methodname>isFileToImport(URI, List)</methodname> returns
                        <code>true</code>, a <classname>SDocument</classname> object is created and
                    added to the current <classname>SCorpusGraph</classname> object. The objects are
                    connected via <classname>SCorpusRelation</classname> or
                        <classname>SCorpusDocumentRelation</classname> objects. While traversing the
                    file-structure, an <classname>SElementId</classname> object is created
                    representing the corpus-hierarchie and added to the created
                        <classname>SCorpus</classname> or <classname>SDocument</classname> objects.
                    A map of these <classname>SElementId</classname> objects corresponding to the
                        <classname>URI</classname> objects is returned, so that in method
                        <methodname>start(SElementId)</methodname> this map can be used to identify
                    the <classname>URI</classname> location of the <classname>SDocument</classname>
                    objects. </para>
                    <note><para>For a description of how to add entries to the file extension list, see
                            <methodname>isFileToImport(URI, List)</methodname>.</para></note>
            </sect2>
            <sect2>
                <title><methodname>isFileToImport</methodname></title>
                <para> To customize the computation if a file shall be imported or not, you can
                    override the method <methodname>isFileToImport</methodname>. The method in its
                    original returns if a given <classname>URI</classname> object shall be imported
                    during import phase. This decision depends on the kind and the content of the
                    given fileExtension list. The file extension list can contain a set of file
                    extensions (Strings without '.') to be imported or marked as to be not imported
                    (via the prefix
                    <varname>PepperImporter.NEGATIVE_FILE_EXTENSION_MARKER</varname>). The following
                    list shows the condition of computation for returned value: <itemizedlist>
                        <listitem>
                            <para>This method returns false, in case of the given
                                    <classname>URI</classname> object is null.</para>
                        </listitem>
                        <listitem>
                            <para>This method returns true for every <classname>URI</classname>
                                object in case of the list is null or empty.</para>
                        </listitem>
                        <listitem>
                            <para>This method returns true if the given list is a positive list
                                (does not contain the negative marker
                                    <varname>PepperImporter.NEGATIVE_FILE_EXTENSION_MARKER</varname>
                                at all) and the file extension of the uri is contained in the
                                list.</para>
                        </listitem>
                        <listitem>
                            <para>This method returns true if the given list is a negative list (any
                                item is prefixed with the negative marker
                                    <varname>PepperImporter.NEGATIVE_FILE_EXTENSION_MARKER</varname>)
                                and the file extension of the uri is not contained in the
                                list.</para>
                        </listitem>
                    </itemizedlist>
                    <note>
                        <para>When a list contains items prefixed with the negative marker and items
                            which are not, the list is interpreted as a negative list.</para>
                    </note>
                </para>
                <para> In case of you want to customize the method by overriding it, but not loosing
                    its functionality, you can use the following lines of code:
                    <programlisting>@Override
protected boolean isFileToImport(URI checkUri, List&lt;String&gt; fileExtensions)
{ 
    if (super.isFileToImport(checkUri))
    //TODO: do something, when super says yes
    else
    //TODO: do something, when super says no 
}</programlisting>
                </para>
            </sect2>
        </sect1>
    </chapter>
    <chapter>
        <title>Documenting your PepperModule</title>
        <para> One of the most important but often forgotten tasks when creating a PepperModule is
            to document the behaviour of it and its functionalities. Therefore the template
            SampleModules contains a template for creating a documentation. The documentation in
            SaltNPepper in general is done in DocBook (see <link xlink:href="docbook.org/"
                >docbook.org/</link>). DocBook is a documentation language written in XML and
            enables to transform the documentation into several target formats like html, pdf, odt,
            doc etc.. <note>
                <para>We recommend to use the template, for a uniform view to all PepperModules.
                    That makes it possible not to forget important issues to be mentioned and makes
                    it easier for the user to have a good understanding of what the PepperModule is
                    doing.</para>
            </note> You will find the template in
                <filename>SAMPLE_MODULES_HOME/src/main/docbkx/manual.xml</filename> among other
            directories containing files necessary for the transformation. Tor refer to images from
            the manual, put the into the image folder
                <filename>SAMPLE_MODULES_HOME/src/main/docbkx/images/</filename> and make a relative
            reference. </para>
        <sect1>
            <title>Transformation</title>
            <para>The standard transformation which is configured for SampleModules is the
                transformation to html and pdf. The configuration is done in the
                    <filename>pom.xml</filename> of the pepper-parentModule project. To add further
                output formats, just copy the respective plugins to your pom and change them.</para>
            <para>When executing the maven goal site <synopsis>mvn clean site</synopsis>, maven will
                create a manual folder under <filename>SAMPLE_MODULES_HOME/target/manual</filename>,
                where you can find the pdf documentation and the html documentation.</para>
            <note>
                <para>The current configuration does not need to be changed, just write your
                    documentation by overriding the template. The rest shall work automatically. In
                    some cases it might be necessary to adopt the transformation, than please take a
                    look to the xsl transformation files in
                        <filename>SAMPLE_MODULES_HOME/docbook-xsl</filename>.</para>
            </note>
        </sect1>
    </chapter>
    <chapter>
        <title>Customizing behaviour of your PepperModule</title>
        <subtitle>via properties</subtitle>
        <para> When creating a mapping inside to either map any format or model to salt or a salt
            model to another salt model or a salt model to any model or format, it is often a matter
            of choice to map some data this way or another. In such cases it might be clever not to
            be that strict and allow only one possiblity. It could be a good idea to leave this
            decision to the user. Customizing a mapping will increse the power of a PepperModule
            enormously, because than it can be used for many purposes without rewriting parts of it.
            Therefore the pepper framework provides a property system to access such user
            customizations. Nevertheless, a PepperModule shall not be dependant on user
            customization, the past showed, that it is very frustrating, when a PepperModule breaks
            up, because of not specifified properties. There should always be a default behaviour in
            case of the user has not specified one. </para>
        <sect1>
            <title>Property</title>
            <para>A property is just an attribute-value pair, consisting of a name so called
                property name and a value so called property value. Properties can be used for
                customizing the behaviour of a mapping of a PepperModule. Such a property must be
                specified by the user and determined in the pepper workflow description. The pepper
                frsamework will pass all customization properties direct to the instance of the
                PepperModule. </para>
            <note>
                <para>In the current version of pepper one has to specify a property file by its
                    location in the pepper workflow description file (.pepperParams) in the
                    attribute @specialParams inside the &lt;importerParams&gt;,
                    &lt;exporterParams&gt; or &lt;moduleParams&gt; element. In the next versions
                    this will change to a posibility for adding properties directly to the pepper
                    workflow description file.</para>
            </note>
        </sect1>
        <sect1>
            <title>Property registration</title>
            <para>The pepper framework provides a kind of a registration for customization
                properties. This registry is called <classname>PepperModuleProperties</classname>
                and can be accessed via <methodname>getProperties()</methodname> and
                    <methodname>setProperties()</methodname>. This class only represents a container
                object for a set of <classname>PepperModuleProperty</classname> objects and provides
                accessing methods. An instance of <classname>PepperModuleProperty</classname>
                represents an abstract description of a property and the concrete value at once. In
                the registration phase it belongs to the tasks of a
                    <classname>PepperModule</classname> to specify the abstract description which
                consists of the name of the property, its datatype, a short description and a flag
                specifying if this property is optional or mandatory. To create such an abstract
                description of a property use the constructor: <constructorsynopsis>
                    <methodname>PepperModuleProperty</methodname>
                    <methodparam>
                        <type>String</type>
                        <parameter>name</parameter>
                    </methodparam>
                    <methodparam>
                        <type>Class&gt;T&lt;</type>
                        <parameter>clazz</parameter>
                    </methodparam>
                    <methodparam>
                        <type>String</type>
                        <parameter>description</parameter>
                    </methodparam>
                    <methodparam>
                        <type>Boolean</type>
                        <parameter>required</parameter>
                    </methodparam>
                </constructorsynopsis> and pass the created property object to the property registry
                by calling the method <methodname>addProperty</methodname>. The pepper framework
                uses the registry to first inform the user about usable properties for customization
                and second to fullfill the property objects with the property values set by the
                user. </para>
            <para>The value of a specific property can be accessed by passing its name to the
                registry. The method to be used is the following one: <methodsynopsis>
                    <methodname>getProperty</methodname>
                    <methodparam>
                        <type>String</type>
                        <parameter>propName</parameter>
                    </methodparam>
                </methodsynopsis>
            </para>
        </sect1>
    </chapter>
    <chapter>
        <title>Testing your PepperModule</title>
        <sect1>
            <title>Running Unit Test</title>
            <para> In package ??? you will find test classes named PepperManipulatortest,
                PepperImporterTest and PepperExporterTest, create your own test classes derived from
                them -these classes implent some tests which will be ran via building in maven or if
                you run a Unit test in development phase - the tests will help you implement good
                code - implemented tests will also check if module can be plugged into the pepper
                framework (means if all necessary values are set) - on second hand these classes
                provide some helper class which can be used for instance the class
                PepperModuleTest.start() runs your PepperModule like Pepper will do, but will return
                a salt graph, so that you can check the creted salt graph against an expected
                template. - here is sample code, to use this tests:
                <programlisting>//start: creating and setting corpus definition
CorpusDefinition corpDef= PepperModulesFactory.eINSTANCE.createCorpusDefinition();
FormatDefinition formatDef= PepperModulesFactory.eINSTANCE.createFormatDefinition();
formatDef.setFormatName(FORMAT_NAME_OF_TEST_CORPUS);
formatDef.setFormatVersion(FORMAT_VERSION_OF_TEST_CORPUS);
corpDef.setFormatDefinition(formatDef);
corpDef.setCorpusPath(URI.createFileURI(rootCorpus.getAbsolutePath()));
this.getFixture().setCorpusDefinition(PATH_TO_TEST_CORPUS);
//end: creating and setting corpus definition
                 	
SCorpusGraph importedCorpusGraph= SaltCommonFactory.eINSTANCE.createSCorpusGraph();
this.getFixture().getSaltProject().getSCorpusGraphs().add(importedCorpusGraph);
this.getFixture().importCorpusStructure(importedCorpusGraph);
                 	
//runs the PepperModule
this.start();
                 	
assertNotNull(importedCorpusGraph.getSDocuments());
assertEquals(..., importedCorpusGraph.getSDocuments().size());
                 	
assertNotNull(importedCorpusGraph.getSCorpora());
assertEquals(..., importedCorpusGraph.getSCorpora().size());                </programlisting>
            </para>
        </sect1>
        <sect1>
            <title>Running live tests</title>
            <para>For running your own PepperModule in a test environment, the pepper framework
                provides a special project for doing this called pepper-testSuite. This project
                first contains an environment to run your module called pepper-testEnvironment and
                contains a second project called pepper-moduleTest for checking the correctness of
                your PepperModule. Correctness means, that your module can be pluged into the
                environment and does not mean the logical correctness of its functionality. This
                project directly runs in the OSGi container and therefore has to be started in it.
                Because of there is starter outside the OSGi environment, you have to pass necessary
                resource locations and test corpora via environment variables.</para>
            <sect2>
                <title>environment variables</title>
                <para>
                    <itemizedlist>
                        <listitem>
                            <para><envar>PEPPER_TEST</envar>to a folder, where the resources of the
                                peppermodules are and the temprorary stuff can be stored</para>
                        </listitem>
                        <listitem>
                            <para><envar>PEPPER_TEST_WORKFLOW_FILE</envar> to the .pepperparams
                                file</para>
                        </listitem>
                    </itemizedlist>
                </para>
            </sect2>
            <sect2>
                <title>Configure OSGi environment</title>
                <para> For running pepper and also its test environment it is very important to use
                    the correct start order for plugins. For instance it is of special interest to
                    start a logger as early as possible to get a logging and not to hide important
                    messages like warnings or errors. For pepper it is important to run the the
                    pepper framework after all plugins are started, otherwise, they will not be
                    registrated to the pepper plugin registry and can therefore not be resolved. </para>
                <para> To avoid this, set the start level (in OSGi) of "pepper-framework" to
                    default-value + 2 and set the start value of the pepper-logReader to 0. </para>
                <para>To make it easier, we provide a preconfigured file, which can be used for
                    this, but only for eclipse. This file contains information for the run
                    configurations of the pepper-testEnvironment project and can be found under
                        <filename>PEPPER_HOME/pepper-testSuite/pepper-testEnvironment/pepper-testEnvironment.launch</filename>.
                    When using this configuration, it will not run correcly out of the box, because
                    you have to enable your project first. Therefore open the run configuration in
                    eclipse open the pepper-testEnvironment entry and click the box left to the name
                    of your project. For checking not to forget one necessary dependency you can
                    click the vlidate button and the eclipse will retrieve all dependencies and list
                    missing ones in case they exist. </para>
            </sect2>
        </sect1>
    </chapter>
    <chapter>
        <title>FAQ</title>
        <sect1>
            <title>Cannot run maven install under Eclipse?</title>
            <para>Restart Eclipse and try again, sometimes Eclipse does not recognize a maven
                project at first time.</para>
        </sect1>

    </chapter>
</book>
